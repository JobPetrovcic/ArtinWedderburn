import Mathlib.RingTheory.Artinian
import Mathlib.Algebra.Field.Defs
import Mathlib.RingTheory.SimpleRing.Basic
import Mathlib.Algebra.Ring.Idempotents
import Mathlib.RingTheory.TwoSidedIdeal.Operations

def both_mul {R : Type*}[Ring R] (a b : R): Set R := {x | ∃ r : R, x = a * r * b}
-- TODO : A better notation?
notation:55 "(" a:55 "⬝" R:55 "⬝" b:55 ")"  => both_mul R a b

variable {R : Type*} [Ring R]

variable (I J : Ideal R) -- Ideals in mathlib are LEFT ideals (defined as Submodule R R)

variable (A B C: Set R)
-- the set of all pairwise products of elements of A and B
open Pointwise Set

namespace IdealProd
  -- the ideal generated by the set of all pairwise products of elements of A and B
  abbrev ring_subset_prod_ideal : Ideal R := Ideal.span (A * B)
  -- there is a multiplicative structure on the set of ideals of a ring
  instance : Mul (Ideal R) := {mul := fun I J => Ideal.span (↑I * ↑J)}
end IdealProd

namespace TwoSidedIdealProd
  abbrev ring_subset_prod_two_sided_ideal : TwoSidedIdeal R := TwoSidedIdeal.span (A * B)
  instance : Mul (TwoSidedIdeal R) := {mul := fun I J => ring_subset_prod_two_sided_ideal ↑I ↑J}


  theorem univ_mul_ideal_eq_ideal (I : TwoSidedIdeal R) : (univ : Set R) * I = I := by
    apply Set.ext_iff.mpr
    intro x
    constructor
    {rintro ⟨y, yu, a, ha, hx⟩;simp at hx;rw [←hx];refine SetLike.mem_coe.mpr ?mp.intro.intro.intro.intro.a;exact TwoSidedIdeal.mul_mem_left I y a ha}
    {intro hx;use 1;simp;trivial}

  theorem mul_univ_ideal_eq_ideal (I : TwoSidedIdeal R) : I * (univ : Set R) = I := by
    apply Set.ext_iff.mpr
    intro x
    constructor
    {rintro ⟨y, yu, a, ha, hx⟩;simp at hx;rw [←hx];refine SetLike.mem_coe.mpr ?mp.intro.intro.intro.intro.a;exact
      TwoSidedIdeal.mul_mem_right I y a yu}
    {intro hx;use x;simp;constructor;trivial;use 1;exact MulOneClass.mul_one x}

  @[simp]
  theorem mul_two_sided_ideal_eq_span (I J : TwoSidedIdeal R) : I * J = ring_subset_prod_two_sided_ideal ↑I ↑J := by
    rfl

  theorem ideal_get_pair_wise_prod (I J : TwoSidedIdeal R) : (TwoSidedIdeal.setLike.coe (I * J)) = AddSubgroup.closure { i * j | (i ∈ I) (j ∈ J)} := by
    ext x
    simp
    rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure]
    nth_rewrite 1 [Eq.symm (mul_assoc _ _ _)]
    rw [univ_mul_ideal_eq_ideal]
    nth_rewrite 1 [←Eq.symm (mul_assoc _ _ _)]
    rw [mul_univ_ideal_eq_ideal]
    exact Eq.to_iff rfl

  theorem ideal_eq_set_eq (I J : TwoSidedIdeal R) (h : (↑I : Set R) = ↑J) : I = J := by
    refine TwoSidedIdeal.ext ?h
    exact fun x ↦ Eq.to_iff (congrFun h x)

  variable (Γ : Type) [AddGroup Γ]
  variable (G H F : AddSubgroup Γ)

  -- Associativity of ideal product
  -- Technically not needed, but would be a useful addition to the library
  --theorem mul_two_sided_ideal_assoc (I J K : TwoSidedIdeal R) : (I * J) * K = I * (J * K) := by sorry

  theorem ideal_eq_span (I : TwoSidedIdeal R): I = TwoSidedIdeal.span I := by
    apply le_antisymm
    {exact @TwoSidedIdeal.subset_span R _ ↑I}
    {intro x hx; apply (@TwoSidedIdeal.mem_span_iff R _ I x).1 hx I; trivial}

  #check TwoSidedIdeal.subset_mul_set
  theorem prod_le_ideal (I J : TwoSidedIdeal R) : I * J ≤ I := by
    nth_rewrite 2 [ideal_eq_span I]
    apply TwoSidedIdeal.span_mono
    apply TwoSidedIdeal.subset_mul_set
    trivial

  theorem prod_le_ideal' (I J : TwoSidedIdeal R) : I * J ≤ J := by
    nth_rewrite 2 [ideal_eq_span J]
    apply TwoSidedIdeal.span_mono
    apply TwoSidedIdeal.set_mul_subset
    trivial

  -- Not needed, but would be a useful addition to the library
  --instance : Semigroup (TwoSidedIdeal R) := by sorry

  theorem mul_top (I : TwoSidedIdeal R) : I * ⊤ = I := by
    apply le_antisymm
    {apply prod_le_ideal}
    {
      nth_rewrite 1 [ideal_eq_span I]
      apply TwoSidedIdeal.span_mono
      intro x hx
      refine mem_mul.mpr ?_
      use x
      simp [hx]
      use (1 : R)
      simp
    }

  theorem top_mul (I : TwoSidedIdeal R) : ⊤ * I = I := by
    apply le_antisymm
    {apply prod_le_ideal'}
    {
      nth_rewrite 1 [ideal_eq_span I]
      apply TwoSidedIdeal.span_mono
      intro x hx
      refine mem_mul.mpr ?_
      use 1
      constructor
      simp
      use x
      simp
      trivial
    }

  -- Already proven if we know that it is a semigroup
  -- Not needed, but would be a useful addition to the library
  --@[simp]
  --instance MulTwoSidedisMonoid: Monoid (TwoSidedIdeal R) :=
  --{
  --  one := ⊤,
  --  one_mul := top_mul
  --  mul_one := mul_top
  --}
end TwoSidedIdealProd
