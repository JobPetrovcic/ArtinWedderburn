import Mathlib.RingTheory.Artinian
import Mathlib.Algebra.Field.Defs
import Mathlib.RingTheory.SimpleRing.Basic
import Mathlib.Algebra.Ring.Idempotents
import Mathlib.RingTheory.TwoSidedIdeal.Operations

def twosidedproduct (R : Type*)[Ring R](a b : R) : Set R := {a * x * b | x : R}
-- A better notation?
notation:55 "(" a:55 "⬝" R:55 "⬝" b:55 ")"  => twosidedproduct R a b

variable {R : Type*} [Ring R]

variable (I J : Ideal R) -- Ideals in mathlib are LEFT ideals (defined as Submodule R R)

variable (A B C: Set R)
-- the set of all pairwise products of elements of A and B
open Pointwise Set
-- the ideal generated by the set of all pairwise products of elements of A and B
abbrev ring_subset_prod_ideal : Ideal R := Ideal.span (A * B)
abbrev ring_subset_prod_two_sided_ideal : TwoSidedIdeal R := TwoSidedIdeal.span (A * B)

-- there is a multiplicative structure on the set of ideals of a ring
instance : Mul (Ideal R) := {mul := fun I J => ring_subset_prod_ideal ↑I ↑J}


instance : Mul (TwoSidedIdeal R) := {mul := fun I J => ring_subset_prod_two_sided_ideal ↑I ↑J}

theorem univ_mul_ideal_eq_ideal (I : TwoSidedIdeal R) : (univ : Set R) * I = I := by
  apply Set.ext_iff.mpr
  intro x
  constructor
  {rintro ⟨y, yu, a, ha, hy⟩;simp at hy;rw [←hy];refine SetLike.mem_coe.mpr ?mp.intro.intro.intro.intro.a;exact TwoSidedIdeal.mul_mem_left I y a ha}
  {intro hx;use 1;simp;trivial}

theorem mul_univ_ideal_eq_ideal (I : TwoSidedIdeal R) : I * (univ : Set R) = I := by
  apply Set.ext_iff.mpr
  intro x
  constructor
  {rintro ⟨y, yu, a, ha, hy⟩;simp at hy;rw [←hy];refine SetLike.mem_coe.mpr ?mp.intro.intro.intro.intro.a;exact
    TwoSidedIdeal.mul_mem_right I y a yu}
  {intro hx;use x;simp;constructor;trivial;use 1;exact MulOneClass.mul_one x}

@[simp]
theorem mul_two_sided_ideal_eq_span (I J : TwoSidedIdeal R) : I * J = ring_subset_prod_two_sided_ideal ↑I ↑J := by
  rfl


theorem set_prod_assoc : A * (B * C) = (A * B) * C := by exact Eq.symm (mul_assoc A B C)


theorem ideal_get_pair_wise_prod (I J : TwoSidedIdeal R) : (TwoSidedIdeal.setLike.coe (I * J)) = AddSubgroup.closure { i * j | (i ∈ I) (j ∈ J)} := by
  ext x
  simp
  rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure]
  nth_rewrite 1 [Eq.symm (mul_assoc _ _ _)]
  rw [univ_mul_ideal_eq_ideal]
  nth_rewrite 1 [←Eq.symm (mul_assoc _ _ _)]
  rw [mul_univ_ideal_eq_ideal]
  exact Eq.to_iff rfl


theorem ideal_eq_set_eq (I J : TwoSidedIdeal R) (h : (↑I : Set R) = ↑J) : I = J := by
  refine TwoSidedIdeal.ext ?h
  exact fun x ↦ Eq.to_iff (congrFun h x)

variable (Γ : Type) [AddGroup Γ]
variable (G H F : AddSubgroup Γ)


theorem afva : AddSubgroup.closure ((AddSubgroup.closure ((G : Set Γ) + (H : Set Γ)) : Set Γ) + (F : Set Γ))  = AddSubgroup.closure ((AddSubgroup.closure ((G : Set Γ) + (H : Set Γ)) : Set Γ ) + (F : Set Γ)) := by exact
  rfl



---- with this we can prove associativity
--theorem mul_two_sided_ideal_assoc (I J K : TwoSidedIdeal R) : (I * J) * K = I * (J * K) := by
--  apply ideal_eq_set_eq
--  rw [ideal_get_pair_wise_prod, ideal_get_pair_wise_prod]
--  ext x
--  constructor
--  {
--    intro x
--  }






-- TODO: Is this already in mathlib? There doesn't seem to be a Mul instance for TwoSidedIdeal in the file that define TwoSidedIdeal


theorem ideal_eq_span (I : TwoSidedIdeal R): I = TwoSidedIdeal.span I := by
  apply le_antisymm
  {exact @TwoSidedIdeal.subset_span R _ ↑I}
  {intro x hx; apply (@TwoSidedIdeal.mem_span_iff R _ I x).1 hx I; trivial}





#check TwoSidedIdeal.subset_mul_set
theorem prod_le_ideal (I J : TwoSidedIdeal R) : I * J ≤ I := by
  nth_rewrite 2 [ideal_eq_span I]
  apply TwoSidedIdeal.span_mono
  apply TwoSidedIdeal.subset_mul_set
  trivial


theorem prod_le_ideal' (I J : TwoSidedIdeal R) : I * J ≤ J := by
  nth_rewrite 2 [ideal_eq_span J]
  apply TwoSidedIdeal.span_mono
  apply TwoSidedIdeal.set_mul_subset
  trivial



--instance : Semigroup (TwoSidedIdeal R) :=
--{
--  mul_assoc := by sorry
--}

#check TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure_nonunital

theorem mul_top (I : TwoSidedIdeal R) : I * ⊤ = I := by
  apply le_antisymm
  {apply prod_le_ideal}
  {
    nth_rewrite 1 [ideal_eq_span I]
    apply TwoSidedIdeal.span_mono
    intro x hx
    refine mem_mul.mpr ?_
    use x
    simp [hx]
    use (1 : R)
    simp
  }


theorem top_mul (I : TwoSidedIdeal R) : ⊤ * I = I := by
  apply le_antisymm
  {apply prod_le_ideal'}
  {
    nth_rewrite 1 [ideal_eq_span I]
    apply TwoSidedIdeal.span_mono
    intro x hx
    refine mem_mul.mpr ?_
    use 1
    constructor
    simp
    use x
    simp
    trivial
  }

--@[simp]
--instance MulTwoSidedisMonoid: Monoid (TwoSidedIdeal R) :=
--{
--  one := ⊤,
--  one_mul := top_mul
--  mul_one := mul_top
--}
