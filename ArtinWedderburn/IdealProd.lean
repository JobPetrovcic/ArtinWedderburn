import Mathlib.RingTheory.Artinian
import Mathlib.Algebra.Field.Defs
import Mathlib.RingTheory.SimpleRing.Basic
import Mathlib.Algebra.Ring.Idempotents
import Mathlib.RingTheory.TwoSidedIdeal.Operations
import Mathlib.Algebra.Group.Submonoid.Basic

-- both_mul a b is the set aRb
def both_mul {R : Type*}[Ring R] (a b : R): Set R := {x | ∃ r : R, x = a * r * b}

notation:55 "(" a:55 "⬝" R:55 "⬝" b:55 ")"  => both_mul R a b

variable {R : Type*} [Ring R]

variable (I J : Ideal R) -- Ideals in mathlib are LEFT ideals (defined as Submodule R R)

variable (A B C: Set R)
-- the set of all pairwise products of elements of A and B
open Pointwise Set

namespace IdealProd
  -- the ideal generated by the set of all pairwise products of elements of A and B
  abbrev ring_subset_prod_ideal : Ideal R := Ideal.span (A * B)
  -- there is a multiplicative structure on the set of ideals of a ring
  instance : Mul (Ideal R) := {mul := fun I J => Ideal.span (↑I * ↑J)}
end IdealProd

namespace TwoSidedIdealProd
  abbrev ring_subset_prod_two_sided_ideal : TwoSidedIdeal R := TwoSidedIdeal.span (A * B)
  instance : Mul (TwoSidedIdeal R) := {mul := fun I J => ring_subset_prod_two_sided_ideal ↑I ↑J}

  -- RI = I
  theorem univ_mul_ideal_eq_ideal (I : TwoSidedIdeal R) : (univ : Set R) * I = I := by
    apply Set.ext_iff.mpr
    intro x
    constructor
    {rintro ⟨y, yu, a, ha, hx⟩;simp at hx;rw [←hx];refine SetLike.mem_coe.mpr ?mp.intro.intro.intro.intro.a;exact TwoSidedIdeal.mul_mem_left I y a ha}
    {intro hx;use 1;simp;trivial}

  -- IR = I
  theorem mul_univ_ideal_eq_ideal (I : TwoSidedIdeal R) : I * (univ : Set R) = I := by
    apply Set.ext_iff.mpr
    intro x
    constructor
    {rintro ⟨y, yu, a, ha, hx⟩;simp at hx;rw [←hx];refine SetLike.mem_coe.mpr ?mp.intro.intro.intro.intro.a;exact
      TwoSidedIdeal.mul_mem_right I y a yu}
    {intro hx;use x;simp;constructor;trivial;use 1;exact MulOneClass.mul_one x}

  @[simp]
  theorem mul_two_sided_ideal_eq_span (I J : TwoSidedIdeal R) : I * J = ring_subset_prod_two_sided_ideal ↑I ↑J := by
    rfl

  theorem ideal_get_pair_wise_prod (I J : TwoSidedIdeal R) : (TwoSidedIdeal.setLike.coe (I * J)) = AddSubgroup.closure { i * j | (i ∈ I) (j ∈ J)} := by
    ext x
    simp
    rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure]
    nth_rewrite 1 [Eq.symm (mul_assoc _ _ _)]
    rw [univ_mul_ideal_eq_ideal]
    nth_rewrite 1 [←Eq.symm (mul_assoc _ _ _)]
    rw [mul_univ_ideal_eq_ideal]
    exact Eq.to_iff rfl

  theorem ideal_eq_set_eq (I J : TwoSidedIdeal R) (h : (↑I : Set R) = ↑J) : I = J := by
    refine TwoSidedIdeal.ext ?h
    exact fun x ↦ Eq.to_iff (congrFun h x)

  variable (Γ : Type) [AddGroup Γ]
  variable (G H F : AddSubgroup Γ)

  -- ideal generated by I is I
  theorem ideal_eq_span (I : TwoSidedIdeal R): I = TwoSidedIdeal.span I := by
    apply le_antisymm
    {exact @TwoSidedIdeal.subset_span R _ ↑I}
    {intro x hx; apply (@TwoSidedIdeal.mem_span_iff R _ I x).1 hx I; trivial}

  -- IJ is a subset of I
  theorem prod_le_ideal (I J : TwoSidedIdeal R) : I * J ≤ I := by
    nth_rewrite 2 [ideal_eq_span I]
    apply TwoSidedIdeal.span_mono
    apply TwoSidedIdeal.subset_mul_set
    trivial

  -- IJ is a subset of J
  theorem prod_le_ideal' (I J : TwoSidedIdeal R) : I * J ≤ J := by
    nth_rewrite 2 [ideal_eq_span J]
    apply TwoSidedIdeal.span_mono
    apply TwoSidedIdeal.set_mul_subset
    trivial


  -- IR = I
  theorem mul_top (I : TwoSidedIdeal R) : I * ⊤ = I := by
    apply le_antisymm
    {apply prod_le_ideal}
    {
      nth_rewrite 1 [ideal_eq_span I]
      apply TwoSidedIdeal.span_mono
      intro x hx
      refine mem_mul.mpr ?_
      use x
      simp [hx]
      use (1 : R)
      simp
    }

  -- RI = I
  theorem top_mul (I : TwoSidedIdeal R) : ⊤ * I = I := by
    apply le_antisymm
    {apply prod_le_ideal'}
    {
      nth_rewrite 1 [ideal_eq_span I]
      apply TwoSidedIdeal.span_mono
      intro x hx
      refine mem_mul.mpr ?_
      use 1
      constructor
      simp
      use x
      simp
      trivial
    }

  -- the product of two ideals is an additive subgroup generated by the the pairwise products of elements of the ideals
  theorem ideal_prod_subgroup_pair_products(I J : TwoSidedIdeal R) : (((I * J) : TwoSidedIdeal R) : Set R) = AddSubgroup.closure ((I : Set R) * (J : Set R)) := by
    ext x
    apply TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure_absorbing
    {
      rintro y z ⟨i, hi, j, hj, k⟩
      simp only at k
      rw [←k, ←mul_assoc]
      refine mul_mem_mul ?h.h_left.intro.intro.intro.intro.a hj
      simp only [SetLike.mem_coe]
      exact TwoSidedIdeal.mul_mem_left I y i hi
    }
    {
      intro y z ⟨i, hi, j, hj, k⟩
      simp only at k
      rw [←k, mul_assoc]
      refine mul_mem_mul hi ?h.h_right.intro.intro.intro.intro.a
      simp only [SetLike.mem_coe]
      exact TwoSidedIdeal.mul_mem_right J j z hj
    }

  -- cl(cl(A*B)*C) = cl(A*B*C)
  theorem subgroup_product_eq (A B C : AddSubgroup R) : AddSubgroup.closure ((((AddSubgroup.closure ((A : Set R) * (B : Set R)))) : Set R) * (C : Set R)) = AddSubgroup.closure ((A : Set R) * (B: Set R) * (C : Set R)) :=  -- Done by Job
    by
      apply le_antisymm
      {
        rw [AddSubgroup.closure_le]
        rintro x ⟨y, hy, c, hc, h⟩
        simp at h
        rw [←h]
        clear h
        induction hy using AddSubgroup.closure_induction with
        | mem z hz => {
          have ⟨a, ha, b, hb, k⟩ := hz
          simp at k
          rw [←k]
          have habc : a * b * c ∈ (A : Set R) * (B: Set R) * (C : Set R) := by {
            use a * b
            use ⟨a, ⟨ha, ⟨b, ⟨hb, by simp only⟩⟩⟩⟩
            use c
          }
          exact AddSubgroup.subset_closure habc
        }
        | one => {simp only [zero_mul, SetLike.mem_coe];apply AddSubgroup.zero_mem _
        }
        | mul t u ht hu hh k => {rw [right_distrib];apply AddSubgroup.add_mem;exact hh;exact k}
        | inv t ht hh => {rw [neg_mul];apply AddSubgroup.neg_mem;exact hh}
      }
      {
        apply AddSubgroup.closure_mono
        apply mul_subset_mul_right
        exact AddSubgroup.subset_closure
      }

  -- cl(A*cl(B*C)) = cl(A*B*C)
  theorem product_subgroup_eq (A B C : AddSubgroup R) : AddSubgroup.closure ((A : Set R) * (AddSubgroup.closure ((B : Set R) * (C : Set R)) : Set R)) = AddSubgroup.closure ((A : Set R) * (B : Set R) * (C : Set R)) := by  -- Done by Job
      apply le_antisymm
      {
        rw [AddSubgroup.closure_le]
        rintro x ⟨a, ha, y, hy, h⟩
        simp at h
        rw [←h]
        clear h
        induction hy using AddSubgroup.closure_induction with
        | mem z hz => {
          have ⟨b, hb, c, hc, k⟩ := hz
          simp at k
          rw [←k]
          have habc : a * b * c ∈ (A : Set R) * (B: Set R) * (C : Set R) := by {
            use a * b
            use ⟨a, ⟨ha, ⟨b, ⟨hb, by simp only⟩⟩⟩⟩
            use c
          }
          rw [←mul_assoc]
          exact AddSubgroup.subset_closure habc
        }
        | one => {simp only [mul_zero, SetLike.mem_coe]; apply AddSubgroup.zero_mem _
        }
        | mul t u ht hu hh k => {rw [left_distrib];apply AddSubgroup.add_mem;exact hh;exact k}
        | inv t ht hh => {simp only [mul_neg, SetLike.mem_coe, neg_mem_iff];exact hh}
      }
      {
        apply AddSubgroup.closure_mono
        rw [mul_assoc]
        apply mul_subset_mul_left
        exact AddSubgroup.subset_closure
      }

  def two_sided_ideal_to_subgroup (I : TwoSidedIdeal R) : AddSubgroup R :=  -- Done by Job
    {
      carrier := I,
      zero_mem' := I.zero_mem,
      add_mem' := I.add_mem,
      neg_mem' := I.neg_mem
    }

  theorem subgroup_of_ideal_carrier_eq_carrier (I : TwoSidedIdeal R) : ((two_sided_ideal_to_subgroup I) : Set R) = I := rfl  -- Done by Job

  -- cl(cl(A*B)*C) = cl(A*B*C)
  theorem ideal_product_subgroup_eq (A B C  : TwoSidedIdeal R) : AddSubgroup.closure ((((AddSubgroup.closure ((A : Set R) * (B : Set R)))) : Set R) * (C : Set R)) = AddSubgroup.closure ((A : Set R) * (B : Set R) * (C : Set R)) := by  -- Done by Job
      have k := subgroup_product_eq (two_sided_ideal_to_subgroup A) (two_sided_ideal_to_subgroup B) (two_sided_ideal_to_subgroup C)
      rw [subgroup_of_ideal_carrier_eq_carrier, subgroup_of_ideal_carrier_eq_carrier, subgroup_of_ideal_carrier_eq_carrier] at k
      exact k

  -- cl(A*cl(B*C)) = cl(A*B*C)
  theorem product_ideal_subgroup_eq (A B C : TwoSidedIdeal R) : AddSubgroup.closure ((A : Set R) * (AddSubgroup.closure ((B : Set R) * (C : Set R)) : Set R)) = AddSubgroup.closure ((A : Set R) * (B : Set R) * (C : Set R)) :=  -- Done by Job
    by
      have k := product_subgroup_eq (two_sided_ideal_to_subgroup A) (two_sided_ideal_to_subgroup B) (two_sided_ideal_to_subgroup C)
      rw [subgroup_of_ideal_carrier_eq_carrier, subgroup_of_ideal_carrier_eq_carrier, subgroup_of_ideal_carrier_eq_carrier] at k
      exact k

  -- (IJ)K = I(JK)
  theorem ideal_mul_assoc (I J K : TwoSidedIdeal R) :  (I * J) * K = I * (J * K) := by -- Done by Job
    refine ideal_eq_set_eq  (I * J * K) (I * (J * K)) ?h
    rw [ideal_prod_subgroup_pair_products, ideal_prod_subgroup_pair_products, ideal_product_subgroup_eq, ←product_ideal_subgroup_eq, ←ideal_prod_subgroup_pair_products, ←ideal_prod_subgroup_pair_products]

  -- Not needed, but would be a useful addition to the library
  instance : Semigroup (TwoSidedIdeal R) := {mul_assoc := ideal_mul_assoc} -- Done by Job
  @[simp]
  instance MulTwoSidedisMonoid: Monoid (TwoSidedIdeal R) := -- Done by Job
  {
    one := ⊤,
    one_mul := top_mul
    mul_one := mul_top
  }

end TwoSidedIdealProd
